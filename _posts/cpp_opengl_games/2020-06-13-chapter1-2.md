---
title:  "[C++, OpenGL] 1.2 기본적인 그리기 - 이동, 회전, 애니메이션" 

categories:
  - C++ games
tags:
  - [Programming, C++, OpenGL, Graphics]

toc: true
toc_sticky: true

date: 2020-06-13
last_modified_at: 2020-06-13
---

인프런에 있는 홍정모 교수님의 **홍정모의 게임 만들기 연습 문제 패키지** 강의를 듣고 정리한 필기입니다. **연습 문제 풀이도 함께 기록했습니다!**😀   
[🌜 공부에 사용된 홍정모 교수님의 코드들 보러가기](https://github.com/jmhong-simulation/GameDevPracticePackage)   
[🌜 [홍정모의 게임 만들기 연습 문제 패키지] 강의 들으러 가기!](https://www.inflearn.com/course/c-2)
{: .notice--warning}

<br>

# Chapter 1. 기본 기능 구현 
# 1.2 기본적인 그리기 - 이동, 회전, 애니메이션
이번 실습 에서는 Game2D 클래스에서 `draw_grid` 값을 true 로 바꾸는 것을 권장!

<br>

## 원점에 검은 점 그리기
### DrawFunction.h

```cpp
using vec2 = Vector2<float>;
```

### vector2.h

```cpp
template<typename T>
	class Vector2
	{
	public:
			union {
				struct { T x, y; };
				struct { T v0, v1; };
				T data[2];
			};
```

### main.cpp

```cpp
namespace jm
{
	class RotatingStarExample : public Game2D
	{
	public:
		void update() override
		{
			const vec2 point = vec2(0.0f, 0.0f); // 점의 위치 지정 (원점)
			drawPoint(Colors::black, point, 5.0f); // 점 그리기 5.0f 크기로
		}
	};
}

int main(void)
{

	jm::RotatingStarExample().init("This is my digital canvas!", 1280, 960, false).run();

	return 0;
}
```

<br>

## 선 그리기

![image](https://user-images.githubusercontent.com/42318591/84530136-942f3500-ad1d-11ea-8842-fb7727051466.png){: width="40%" height="40%"}{: .align-center}

```cpp
	class RotatingStarExample : public Game2D
	{
	public:
		void update() override
		{
			const vec2 p0(0.0f, 0.0f); // 시작점 (vector2 생성자로 구현)
			const vec2 p1(0.5f, 0.5f);//  끝점
			drawLine(Colors::red, p0, Colors::blue, p1); 
			// 첫번재점 레드, 두번째점 블루 -> 빨강에서 시작해서 끝으로 갈수록 블루인 선이 됨
		}
	};
```

<br>

## 삼각형 그리기
삼각형은 선이 3개 !

![image](https://user-images.githubusercontent.com/42318591/84530309-e2dccf00-ad1d-11ea-88b1-8ed1e86a81be.png){: width="40%" height="40%"}{: .align-center}

```cpp
	class RotatingStarExample : public Game2D
	{
	public:
		void update() override
		{
			const vec2 p0(0.0f, 0.0f);
			const vec2 p1(0.5f, 0.5f);
			const vec2 p2(0.5f, 0.0f);
			drawLine(Colors::red, p0, Colors::blue, p1);
			drawLine(Colors::red, p1, Colors::blue, p2);
			drawLine(Colors::red, p2, Colors::blue, p0);
		}
	};
```

<br>

## 평행이동 방법 1. 각 좌표 파라미터에 값을 더해주기
각 좌표 파라미터에 이동시킬 만큼 실수 값을 더해주면 된다.

![image](https://user-images.githubusercontent.com/42318591/84530374-03a52480-ad1e-11ea-8470-e652684e82e5.png){: width="40%" height="40%"}{: .align-center}

```cpp
	class RotatingStarExample : public Game2D
	{
	public:
		void update() override
		{
			const float dx = 0.1f;  // dy도 추가해서 y좌표에 더해주면 y 방향 평행이동도 가능

			const vec2 p0(0.0f + dx, 0.0f);
			const vec2 p1(0.5f + dx, 0.5f);
			const vec2 p2(0.5f + dx, 0.0f);
			drawLine(Colors::red, p0, Colors::blue, p1);
			drawLine(Colors::red, p1, Colors::blue, p2);
			drawLine(Colors::red, p2, Colors::blue, p0);
		}
	};
```

<br>

## 평행이동 방법 2. 좌표 자체를 넘겨주기 + translate함수 사용
- 각 파라미터에 적용시키는건 번거로우니까 <u>좌표 자체인 vec2객체를 넘겨주기</u>
- `translate 함수` : <u>누적</u> 해서 좌표 현재위치를 변경시킨다. 

![image](https://user-images.githubusercontent.com/42318591/84530801-7b734f00-ad1e-11ea-877e-82a5334a4b7e.png){: width="40%" height="40%"}{: .align-center}

```cpp
	class RotatingStarExample : public Game2D
	{
	public:
		void update() override
		{
			translate(0.1f, 0.0f); 
            // 점의 시작 위치가 (0.1f, 0.0f) 가 되어 이 아래에 작성한 모든 도형들이 (0.1f, 0.0f) 위치에서 그려지게 된다.

			const vec2 p0(0.0f , 0.0f);
			const vec2 p1(0.5f , 0.5f);
			const vec2 p2(0.5f , 0.0f);
			drawLine(Colors::red, p0, Colors::blue, p1); // vec2 p1을 넘겨줌
			drawLine(Colors::red, p1, Colors::blue, p2); // vec2 p2을 넘겨줌
			drawLine(Colors::red, p2, Colors::blue, p0); // vec2 p0을 넘겨줌

			// 이 아래 3개의 선은 이제 (0.2f, 0.0f) 위치에서 그려진다. (translate은 누적되니까 한번 더 translate을 해주니 (0.2f, 0.0f)가 됨)
			translate(0.1f, 0.0f); 
			drawLine(Colors::red, p0, Colors::blue, p1);
			drawLine(Colors::red, p1, Colors::blue, p2);
			drawLine(Colors::red, p2, Colors::blue, p0);
		}
	};
```

## 평행이동 방법 3. 좌표 자체를 넘겨주기 + beginTransformation, endTransformation 사용

- 어느 일정 부분안에서만 누적되게 하고 싶을 때.
- `beginTransformation()` 과 `endTransformation()` 의 사이에서 이루어진 변환들이 이 범위를 벗어나면 초기화된다.

![image](https://user-images.githubusercontent.com/42318591/84531044-e7ee4e00-ad1e-11ea-90dd-8f98ac384edf.png){: width="40%" height="40%"}{: .align-center}

```cpp
	class RotatingStarExample : public Game2D
	{
	public:
		void update() override
		{
			beginTransformation(); // 여기서부터

			translate(0.1f, 0.0f);  // (0.1f,0.0f)에 그려지는 아래 3개의 실선

			const vec2 p0(0.0f , 0.0f);
			const vec2 p1(0.5f , 0.5f);
			const vec2 p2(0.5f , 0.0f);
			drawLine(Colors::red, p0, Colors::blue, p1);
			drawLine(Colors::red, p1, Colors::blue, p2);
			drawLine(Colors::red, p2, Colors::blue, p0);

			translate(0.1f, 0.0f);   // (0.2f,0.0f) 에 그려지는 아래 3개의 실선
			drawLine(Colors::red, p0, Colors::blue, p1);
			drawLine(Colors::red, p1, Colors::blue, p2);
			drawLine(Colors::red, p2, Colors::blue, p0);

			endTransformation();  // 여기까지만 누적이 적용된다 !  이제 여기를 벗어나면 다시 원점인 (0.0f,0.0f) 으로 돌아감

			translate(-0.1f, 0.0f);  // (-0.1f, 0.0f) 에 그려지는 아래 3개의 실선
			drawLine(Colors::red, p0, Colors::blue, p1);
			drawLine(Colors::red, p1, Colors::blue, p2);
			drawLine(Colors::red, p2, Colors::blue, p0);
		}
	};
```

<br>

## 박스 그리기

![image](https://user-images.githubusercontent.com/42318591/84531394-824e9180-ad1f-11ea-81f2-d7dde4905698.png){: width="40%" height="40%"}{: .align-center}

```cpp
	class RotatingStarExample : public Game2D
	{
	public:
		void update() override
		{
			drawWiredBox(Colors::gold, 0.5f, 0.25f);
		}
	};
```

<br>

## 회전 : 원점 회전
- `rotate`함수는 <u>원점에 대해서 회전한다.</u>
- 회전 하는 중심이 원점 기준임.

![image](https://user-images.githubusercontent.com/42318591/84531564-bd50c500-ad1f-11ea-9382-2a359328d863.png){: width="40%" height="40%"}{: .align-center}

```cpp
	class RotatingStarExample : public Game2D
	{
	public:
		void update() override
		{
			drawWiredBox(Colors::gold, 0.5f, 0.25f);
			rotate(30.0f); // (0.0f, 0.0f) 현재 위치인 원점에 대해서 30도 회전
			drawWiredBox(Colors::blue, 0.5f, 0.25f);
		}
	};
```

<br>

## 회전 : 그래픽스는 내부적으로 역순으로 실행된다. ⭐

![image](https://user-images.githubusercontent.com/42318591/84531793-14569a00-ad20-11ea-92db-1ba0f781aeea.png){: width="40%" height="40%"}{: .align-center}

```cpp
	class RotatingStarExample : public Game2D
	{
	public:
		void update() override
		{
			drawWiredBox(Colors::gold, 0.5f, 0.25f);
			
			// 파란색 상자는 그냥 rotate만 적용된 것
			beginTransformation();
			rotate(30.0f);
			drawWiredBox(Colors::blue, 0.5f, 0.25f);
			endTransformation();

			// 빨간 상자는 translate 후에 rotate까지 함께 적용된 것
			beginTransformation();
			translate(0.25f, 0.0f); // translate이 코드 상 rotate보다 먼저 등장
			rotate(30.0f); // rotate이 translate 코드에서 아랫줄에 위치.
			drawWiredBox(Colors::red, 0.5f, 0.25f);
			endTransformation();
		}
	};
```

- 사진에서 <u>빨간 상자 주목 !</u> 코드 상으로는 translate을 먼저 한 후에 rotate을 하므로 이동 후 원점에 대해서 회전하는 그림이 나와햐 하는데 실제로 실행해보면 rotate을 먼저 하고 난 후에 translate 평행이동 한 그림이 나온다.
  - 컴퓨터 크래픽스 API는 **<u>내부적으로 코드의 역순으로 실행</u>**되기 때문. 코드상 `평행이동 → 회전`이여도 내부적으론 **역순으로** `회전 → 평행이동`으로 실행된다.
- 단 <u>draw, 그림을 그리는건 코드 순서 그대로 그려진다!</u>
  - ***이동, 회전, scale 같은 것들만*** <u>코드의 역순으로</u> 진행되는 것.

![image](https://user-images.githubusercontent.com/42318591/84532313-fe95a480-ad20-11ea-92f5-8075b6834f59.png){: width="40%" height="40%"}{: .align-center}

```cpp
drawWiredBox(Colors::gold, 0.5f, 0.25f);
			
// 블루 박스는 코드 상으론 **평행이동->회전** 순     : 그러나 실제론 **회전 -> 평행이동** 순으로 실행됨*
beginTransformation();
translate(0.25f, 0.0f);
rotate(30.0f);
drawWiredBox(Colors::blue, 0.5f, 0.25f);
endTransformation();

// 블루 박스는 코드 상으론 **회전 -> 평행이동** 순     : 그러나 실제론 **평행이동->회전** 순으로 실행됨*
beginTransformation();
rotate(30.0f);
translate(0.25f, 0.0f);
drawWiredBox(Colors::red, 0.5f, 0.25f);
endTransformation();
```

<br>

## 원점이 아닌 점에 대해서 회전하고 싶을 때

    1. 원점이 아닌 점이 원점에 위치할 수 있도록 물체를 통째로 들어서 옮기기
    2. 원점에 위치한 상태에서 원점에 대해서 회전 시키고
    3. 다시 원래 자리로 되돌려 놓기

1 . 원점이 아닌 점이 원점에 위치할 수 있도록 물체를 통째로 들어서 옮기기

![image](https://user-images.githubusercontent.com/42318591/84532739-b6c34d00-ad21-11ea-92bb-5c11a0307f06.png){: width="30%" height="30%"}

```cpp
setLineWidth(3.0f);
const vec2 center_of_rotation(-0.25f, 0.0f);  // 이 점에 대해서 회전시키고 싶어.

translate(-center_of_rotation);  // ⭐ 실행순서 3. (+0.25f, 0.0f)만큼 이동시킨다. 원점으로 이동시키기 위해.
drawWiredBox(Colors::gold, 0.5f, 0.25f); // 실행순서 1.
drawPoint(Colors::black, center_of_rotation, 10.0f); // 실행순서 2. 회전 중점으로 하고 싶은 점을 시각적으로 보기 위해 그 점을 그림.
```

<br>

2 . 원점에 위치한 상태에서 원점에 대해서 회전 시키고

![image](https://user-images.githubusercontent.com/42318591/84532912-17eb2080-ad22-11ea-8dde-890f9caee7a0.png){: width="30%" height="30%"}

```cpp
setLineWidth(3.0f);

const vec2 center_of_rotation(-0.25f, 0.0f);

rotate(45.0f);   // ⭐ 실행순서 4.  
translate(-center_of_rotation);  // 실행순서 3.
drawWiredBox(Colors::red, 0.5f, 0.25f); // 실행순서 1. 
drawPoint(Colors::black, center_of_rotation, 10.0f); // 실행순서 2.
```

<br>

3 . 다시 원래 자리로 돌려놓기
- 이제 (0.25f, 0.0f) 좌표에 대해서 45도 회전하는 그림이 나오게 됐다.
- draw는 코드 순서대로 실행되나 코드상으로는 rotate가 translate보다 먼저 나왔음에도 불구하고 translate이 먼저 실행되고 rotate이 그 다음에 실행된다.

![image](https://user-images.githubusercontent.com/42318591/84533283-c4c59d80-ad22-11ea-82c1-9f901ce3b987.png){: width="30%" height="30%"}

```cpp
setLineWidth(3.0f);

const vec2 center_of_rotation(-0.25f, 0.0f);

translate(center_of_rotation); // ⭐ 실행순서 5. 다시 원래 자리로 돌려 놓기. 
rotate(45.0f);   // 실행순서 4.  
translate(-center_of_rotation);  // 실행순서 3. 
drawWiredBox(Colors::red, 0.5f, 0.25f); // 실행순서 1. 
drawPoint(Colors::black, center_of_rotation, 10.0f); // 실행순서 2.
```

<br>

## 크기 바꾸기 scale
- `scale(a, b)` : x 방향으로 <u>a 배</u>, y 방향으로 <u>b 배</u>로 크기를 바꿈

![image](https://user-images.githubusercontent.com/42318591/84533682-9a281480-ad23-11ea-9b5d-381bd5f8df71.png){: width="30%" height="30%"}{: .align-center}

```cpp
void update() override
		{
			setLineWidth(3.0f);

			scale(2.0f, 0.25f);  // x방향으로 2배, y방향으로 1/4배 
			drawWiredBox(Colors::blue, 1.0f, 1.0f);

		}
```

<br>

## rotation & scale & translate 함께 쓰기

```cpp
namespace jm
{
	class RotatingStarExample : public Game2D
	{
	public:
		float time = 0;
		void update() override
		{
			setLineWidth(3.0f);

			rotate(time*90.0f);   // scale -> rotate 으로 역순으로 실행되게 된다.
			scale(2.0f, 0.25f);
			drawWiredBox(Colors::blue, 1.0f, 1.0f);

			time += this->getTimeStep();
		}
	};
}
```

```cpp
void update() override
		{
			setLineWidth(3.0f);

			scale(2.0f, 0.25f);    //  rotate 먼저 하고 그 다음에 scale 하기 때문에 결과가 다르다.
			rotate(time*90.0f);
			drawWiredBox(Colors::blue, 1.0f, 1.0f);

			time += this->getTimeStep();
		}
```

<u>rotate 두번 하면 마치 자전과 동시에 공전 하는 느낌으로 회전한다.</u>

<br>

# 연습문제

## 🙋 Q1. 공전하는 태양계 만들기

main의 jm::SolarSystem().run()과 `SolarSystem.h` 헤더 파일을 이용하여 별이 가운데 있고 지구는  별을 공전하고 달은 지구를 공전하고 태양은 자전하게끔 만들어보자. *(Hint! rotate 2번만 하면 된다.)*

### 내 풀이

#### 📃 Solarsystem.h + main.cpp
- 이미 구현 되어있는 것.
- 이 헤더 파일을 활용했다.

- 별 현재 위치 : 0,0
- 지구 현재 위치 : 0.5,0
- 달 현재 위치 : 0.7,0

```cpp
#include "Game2D.h"

namespace jm
{
	class SolarSystem : public Game2D
	{
		float time = 0.0f;

	public:
		void update() override
		{
			beginTransformation();
			{
				drawFilledStar(Colors::gold, 0.2f, 0.13f);	// Sun

				translate(0.5f, 0.0f);
				drawFilledCircle(Colors::blue, 0.1f);		// Earth

				translate(0.2f, 0.0f);
				drawFilledCircle(Colors::yellow, 0.05f);	// Moon
			}
			endTransformation();

			time += this->getTimeStep();

		}
	};
}
```

```cpp
#include "SolarSystem.h"

int main(void)
{
	jm::SolarSystem().run();
	
	return 0;
}
```

#### 📃 내 답안

![image](https://user-images.githubusercontent.com/42318591/84534624-3dc5f480-ad25-11ea-8195-a6d7e1a67d96.png){: width="100%" height="100%"}{: .align-center}

- 지구, 달을 일부러 별 모양으로 그렸다. '자전'하는지 보려고! 원모양이면 자전해도 회전 안 하는걸로 보이니까! 
- 그리고 일부러 달의 속도를 눈에 띄게 보려고 빠르게 150으로 조정함.
- 최종적으로 
  - 달은 rotate을 동시에 2개를 하는 모양이 된다.
  - 지구를 150 속도로 공전하면서 동시에 태양을 45 속도로 공전하는 모양이 된다. 

```cpp
#include "Game2D.h"

namespace jm
{
	class SolarSystem : public Game2D
	{
		float time = 0.0f;

	public:
		void update() override
		{
			const vec2 earth(0.5f, 0.0f);
			const vec2 moon(0.2f, 0.0f);

			beginTransformation();	    
			{                        
				rotate(time*45.0f);                           // 실행순서 7. ( 달 + 지구 + 태양 )이 함께 회전한다.
				drawFilledStar(Colors::gold, 0.2f, 0.13f);	  // 실행순서 1. 원점에 태양을 그린다

				translate(earth);                             // 실행순서 6. ( 달 + 지구 ) 가 함께 평행이동한다. 달 (0.7,0.0) 지구(0.5,0.0)
				drawFilledStar(Colors::blue, 0.1f, 0.07f);	  // 실행순서 2. 원점에 지구를 그린다 ( 태양 위에 지구가 그려진다 )
	
				rotate(time*150.0f);                          // 실행순서 5. 달만 원점에 대해 공전한다. (원점을 공전하는 모습)
				translate(moon);                              // 실행순서 4. 달만 평행이동한다. 달 좌표 (0.2, 0.0)
				drawFilledStar(Colors::yellow, 0.05f, 0.03f); // 실행순서 3. 원점에 달을 그린다 ( 지구 위에 달이 그려진다.) 여기까지 마치면 원점에서 태양 위에 지구 위에 달 이렇게 세 개가 겹쳐져 있는 모습이 된다.
			}
			endTransformation();

			time += this->getTimeStep();                                         
		}
	};
}
```

#### 📃 번외. beginTransformation을 이해하기 위해 작성한 필기

- 달은 태양을 150 속도로 공전한다.  ( 이동 → 회전 : 즉 원점을 공전하는 것처럼 )
- 지구는 태양을 45 속도로 공전한다. ( 이동 → 회전 : 즉 원점을 공전하는 것처럼 )
- 태양은 45 속도로 자전한다 ( 회전 : 원점 제자리에서 자전하는 것 처럼)
- 즉 `beginTransformation`과 `endTransformation` 안에 있는 지구와 태양만 원점 45도 회전 영향을 받는다.
- 달은 `rotate(time*150.0f`)과 `translate(moon);`에만 영향을 받았다.

![image](https://user-images.githubusercontent.com/42318591/84534821-97c6ba00-ad25-11ea-8a5a-31193b3f1b62.png){: width="50%" height="50%"}{: .align-center}

```cpp
namespace jm
{
	class SolarSystem : public Game2D
	{
		float time = 0.0f;

	public:
		void update() override
		{
			const vec2 earth(0.5f, 0.0f);
			const vec2 moon(0.2f, 0.0f);

			beginTransformation();	// 이 범위를 벗어나면 rotate도 더 이상 적용되지 않는다.
			{
				
				rotate(time*45.0f);
				drawFilledStar(Colors::gold, 0.2f, 0.13f);	// Sun

				translate(earth);
				drawFilledStar(Colors::blue, 0.1f, 0.07f);		// Earth
				
			}
			endTransformation();

			rotate(time*150.0f);
			translate(moon);
			drawFilledStar(Colors::yellow, 0.05f, 0.03f); // moon

			time += this->getTimeStep();

		}
	};
}
```

<br>

## 🙋 Q2. 얼굴 그리기

### 📃 FaceExample.h 과 필기

![image](https://user-images.githubusercontent.com/42318591/84535026-effdbc00-ad25-11ea-8610-1324c70a51de.png){: width="50%" height="50%"}{: .align-center}

```cpp
#pragma once

#include "Game2D.h"

namespace jm
{
	class FaceExample : public Game2D
	{
	public:
		void update() override
		{
			// Big yellow face
			drawFilledCircle(Colors::yellow, 0.8f); // draw background object first

			// Red mouth
			beginTransformation();
			{
				translate(0.0f, -0.6f);
				scale(3.0f, 1.0f);
				drawFilledCircle(Colors::red, 0.1f);
			}
			endTransformation();

			// Blue nose
			beginTransformation();
			{
				rotate(-10.0f);		                  //⭐ 4. 회전
				scale(1.0f, 2.0f);                    //⭐ 3. 크기를 늘린다
				translate(0.0f, -0.1f);               //⭐ 2. 평행이동
				drawFilledCircle(Colors::blue, 0.1f); //⭐ 1. 코를 그린다
			}
			endTransformation();

			// left eye
			beginTransformation();
			{
				translate(-0.3f, 0.2f);
				rotate(-45.0f);		// 10 degrees rotated 
				drawFilledBox(Colors::black, 0.1f, 0.4f);
				drawFilledBox(Colors::black, 0.4f, 0.1f);
			}
			endTransformation();

			// right eye
			beginTransformation();
			{
				translate(+0.25f, 0.3f);                      //⭐ 4. 오른쪽 눈의 위치로 평행이동
				rotate(-45.0f);		                          //⭐ 3. 45도 돌리면 x 자 모양 
				drawFilledBox(Colors::olive, 0.1f, 0.4f);     //⭐ 1. 세로로 긴 직사각형  ( 교차하며 + 모양 됨 )
				drawFilledBox(Colors::olive, 0.4f, 0.1f);     //⭐ 2. 가로로 긴 직사각형 
			}
			endTransformation();

			for (float x = -0.5f; x < 0.4f; x += 0.05f)  // ⭐ 머릿카락 사선 줄 긋기 ( x 방향 평행이동 하며 )
			{
				drawLine(Colors::black, vec2(x, 0.6f), Colors::gray, vec2(x + 0.05f, 0.85f));
			}
		}
	};
}
```

### 📃 main.cpp

```cpp
#include "FaceExample.h"

int main(void)
{
	jm::FaceExample().run();
	return 0;
}
```

***
<br>

    🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
    언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}