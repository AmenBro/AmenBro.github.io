---
title:  "[C++로 풀이] 카드 짝 맞추기 (순열 속 순열, 완전탐색, DFS, BFS)⭐⭐⭐" 

categories:
  - Programmers
tags:
  - [Algorithm, Coding Test]

toc: true
toc_sticky: true

date: 2021-03-27
last_modified_at: 2021-03-27
---
**C++**로 풀이했습니다.  
출처 : **프로그래머스** <https://programmers.co.kr/learn/challenges>
{: .notice--warning}

# 📌 카드 짝 맞추기

> 난이도 ⭐⭐⭐

## 🚀 문제

![image](https://user-images.githubusercontent.com/42318591/112717406-cff35e00-8f2f-11eb-9125-ea1238871f3f.png)

![image](https://user-images.githubusercontent.com/42318591/112717577-11d0d400-8f31-11eb-81fd-d64698192a71.png)

![image](https://user-images.githubusercontent.com/42318591/112717567-f6fe5f80-8f30-11eb-8aa7-e62ec5ab2989.png)

![image](https://user-images.githubusercontent.com/42318591/112717592-32009300-8f31-11eb-9927-8889c84ae6ea.png)

![image](https://user-images.githubusercontent.com/42318591/112717604-39c03780-8f31-11eb-9fa9-c2bc604cf8f2.png)


<br>

## 🚀 내 풀이 

### 🔥 DFS + BFS 사용한 풀이 ⭕

```cpp
#include <string>
#include <vector>
#include <queue>

using namespace std;

#define INF 9999
int n = 0;
int answer = 0;
struct Pos {
    int r;
    int c;
};
int dirR[] = { 0, 0, -1, 1 };
int dirC[] = { 1, -1, 0, 0 };
vector<vector<Pos>> allCard(7);
vector<bool> numOfCard_visited(7);
vector<vector<bool>> singleCard_visited(7);

void SmallDFS(vector<vector<int>> board, vector<Pos> sameCards, int cardNum, Pos card, int dist, int small_depth, int big_depth);

vector<vector<Pos>> Categorize(vector<vector<int>> board) {
    vector<vector<Pos>> allCard(7);
    for (int i = 0; i < board.size(); ++i) {
        for (int j = 0; j < board[i].size(); ++j) {
            if (board[i][j] != 0) {
                allCard[board[i][j]].push_back({ i, j });
                n++;
            }
        }
    }
    n /= 2;

    for (int i = 0; i < allCard.size(); ++i) {
        vector<bool> v(allCard[i].size());
        singleCard_visited[i] = v;
    }
        
                
    return allCard;
}

int BFS(vector<vector<int>> board, Pos startCard, Pos destCard) {
    queue<Pos> q;
    vector<vector<bool>> checked(4, vector<bool>(4));
    vector<vector<int>> dist(4, vector<int>(4));

    q.push(startCard);
    checked[startCard.r][startCard.c] = true;
    dist[startCard.r][startCard.c] = 0;

    while (!q.empty()) {
        int nowR = q.front().r;
        int nowC = q.front().c;
        q.pop();

        for (int i = 0; i < 4; ++i) {
            int nextR = nowR + dirR[i];
            int nextC = nowC + dirC[i];

            if (nextR < 0 || nextC < 0 || nextR >= 4 || nextC >= 4)
                continue;
            if (checked[nextR][nextC])
                continue;

            q.push({ nextR, nextC });
            checked[nextR][nextC] = true;
            dist[nextR][nextC] = dist[nowR][nowC] + 1;
        }

        for (int i = 0; i < 4; ++i) {
            int nextR = nowR;
            int nextC = nowC;
            bool found = false;
            while (!found) {
                if (nextR + dirR[i] < 0 || nextC + dirC[i] < 0 || nextR + dirR[i] >= 4 || nextC + dirC[i] >= 4)
                    break;
                if (board[nextR + dirR[i]][nextC + dirC[i]] != 0) 
                    found = true;

                nextR += dirR[i];
                nextC += dirC[i];
            }

            if (checked[nextR][nextC])
                continue;

            q.push({ nextR, nextC });
            checked[nextR][nextC] = true;
            dist[nextR][nextC] = dist[nowR][nowC] + 1;
        }
    }

    return dist[destCard.r][destCard.c];
}

void BigDFS(vector<vector<int>> board, Pos card, int dist, int small_depth, int big_depth) {
    if (big_depth == n) {
        if (dist < answer)
            answer = dist;
        return;
    }

    for (int i = 1; i <= 6; ++i) {
        if (allCard[i].size() == 0)
            continue;
        if (numOfCard_visited[i] == false) {
            vector<Pos> sameCards = allCard[i];
            vector<bool>& sameCard_visited = singleCard_visited[i];
            SmallDFS(board, sameCards, i, card, dist, 0, big_depth);
            numOfCard_visited[i] = false;
        }
    }
}

void SmallDFS(vector<vector<int>> board, vector<Pos> sameCards, int cardNum, Pos card, int dist, int small_depth, int big_depth) {
    if (small_depth == 2) {
        dist += 2;
        bool flag = true;
        for (int i = 0; i < singleCard_visited[cardNum].size(); ++i) {
            if (singleCard_visited[cardNum][i] == false) {
                flag = false;
                break;
            }
        }
        if (flag)
            numOfCard_visited[cardNum] = true;
        BigDFS(board, card, dist, 0, big_depth + 1);
        return;
    }

    for (int i = 0; i < sameCards.size(); ++i) {
        if (singleCard_visited[cardNum][i] == false) {
            singleCard_visited[cardNum][i] = true;
            Pos nextCard{ sameCards[i].r, sameCards[i].c };
            int newDist = dist + BFS(board, card, nextCard);
            board[sameCards[i].r][sameCards[i].c] = 0;
            SmallDFS(board, sameCards, cardNum, nextCard, newDist, small_depth + 1, big_depth);
            board[sameCards[i].r][sameCards[i].c] = cardNum;
            singleCard_visited[cardNum][i] = false;
        }
    }
}

int solution(vector<vector<int>> board, int r, int c) {
    answer = INF;
    n = 0;
    allCard = Categorize(board);
    Pos start{ r, c };
    BigDFS(board, start, 0, 0, 0);
    return answer;
}
```

![image](https://user-images.githubusercontent.com/42318591/112717667-902d7600-8f31-11eb-9b8a-1a3c23c6d374.png)

코드 해설 곧 추가 예정!

***
<br>

    🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
    언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}