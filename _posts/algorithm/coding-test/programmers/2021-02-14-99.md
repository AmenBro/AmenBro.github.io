---
title:  "[C++로 풀이] 자물쇠와 열쇠 (완전 탐색)⭐⭐⭐" 

categories:
  - Programmers
tags:
  - [Algorithm, Coding Test]

toc: true
toc_sticky: true

date: 2021-02-14
last_modified_at: 2021-02-14
---
**C++**로 풀이했습니다.  
출처 : **프로그래머스** <https://programmers.co.kr/learn/challenges>
{: .notice--warning}

# 📌 자물쇠와 열쇠

> 난이도 ⭐⭐⭐

## 🚀 문제

![image](https://user-images.githubusercontent.com/42318591/107867665-13ce5e80-6ec0-11eb-84c7-9ccc152668ef.png)

![image](https://user-images.githubusercontent.com/42318591/107867672-1df05d00-6ec0-11eb-897d-a22627244e94.png)

<br>

## 🚀 내 풀이 ⭕

### ✈ 1 차 풀이 ❌ (DFS) (작성하다 말았던 코드입니다.)

```cpp
// 💚현재 모습에서 시계방향 90도로 회전시키기 (pos에 1의 위치를 기록)💚
void rotate(int m, vector<pair<int, int>>& pos) {
    for (int i = 0; i < pos.size(); i++) {
        int temp_row = pos[i].first;
        int temp_col = pos[i].second;
        pos[i].first = temp_col;
        pos[i].second = m - 1 - temp_row;
    }
}

// ⭐🌈 DFS 로 현재의 key의 "회전된 모습"에서 상하좌우 모든 이동 조합 구해나가기. lock의 홈과 완전히 일치하면 종료 🌈⭐
void DFS(vector<pair<int, int>>& keywayPos, int& keyway, vector<vector<int>> key, bool& answer, int dir) {
    
    // 이동
    for (int i = 0; i < key.size(); i++) {
        for (int j = 0; j < key.size(); j++) {
            /* 1️⃣ "상" 이동 */ 
            // 👉 1. 이동시키기(key의 1값 전부 위로 한칸씩 이동) 
            // 2. lock 과 일치하는지 검사 
            // 3. 일치하면 answer = ture 후 종료하고 일치하지 않다면 ⭐🌈 DFS 로 <다음 이동>하러가기 🌈⭐

            /* 2️⃣ "하" 이동 */ 
            // 👉 1. 이동시키기(key의 1값 전부 아래로 한칸씩 이동) 
            // 2. lock 과 일치하는지 검사 
            // 3. 일치하면 answer = ture 후 종료하고 일치하지 않다면 ⭐🌈 DFS 로 <다음 이동>하러가기 🌈⭐

            /* 3️⃣ "좌" 이동 */ 
            // 👉 1. 이동시키기(key의 1값 전부 왼쪽으로 한칸씩 이동) 
            // 2. lock 과 일치하는지 검사 
            // 3. 일치하면 answer = ture 후 종료하고 일치하지 않다면 ⭐🌈 DFS 로 <다음 이동>하러가기 🌈⭐

            /* 4️⃣ "우" 이동 */ 
            // 👉 1. 이동시키기(key의 1값 전부 오른쪽로 한칸씩 이동) 
            // 2. lock 과 일치하는지 검사 
            // 3. 일치하면 answer = ture 후 종료하고 일치하지 않다면 ⭐🌈 DFS 로 <다음 이동>하러가기 🌈⭐
        }
    }

    
    return;
}

bool solution(vector<vector<int>> key, vector<vector<int>> lock){
     bool answer = false;
    int m = key.size();  // m X m
    int n = lock.size(); // n X n

    // 1️⃣ key의 크기가 lock과 동일해지도록 (n x n) key에 살을 붙인다.  
    for (int i = 0; i < m; ++i) {
        while (key[i].size() < n) {
            key[i].push_back(0);
        }
    }
    while (key.size() < n) {
        vector<int> v(n, 0);
        key.push_back(v);
    }

    // 2️⃣ key의 1의 위치들 저장 (= 돌기의 위치) 
    vector<pair<int, int>> bumpPos;
    for (int i = 0; i < n; i++) 
        for (int j = 0; j < n; j++) 
            if (key[i][j] == 1) 
                bumpPos.push_back(make_pair(i, j));

    // 3️⃣ lock의 0의 위치들 저장 (= 홈의 위치) 
    vector<pair<int, int>> keywayPos;
    for (int i = 0; i < n; i++) 
        for (int j = 0; j < n; j++) 
            if (lock[i][j] == 1) 
                keywayPos.push_back(make_pair(i, j));

    // 4️⃣ "회전"은 4가지뿐 ! 회전 별로 상하좌우 "이동"의 모든 조합은 DFS로
    // key 를 각각 4가지로 회전해본 후 회전 별로 상하좌우 이동 모든 조합을 DFS로 검사해서 key의 돌기(1)가 lock의 홈(0)과 일치할 때를 찾으면 DFS 종료하도록
    for (int i = 0; i < 4; ++i) { // 4가지의 회전 (0 : 회전 X, 1 : 90도 회전, 2 : 180도 회전, 3 : 270도 회전)
        if (i != 0) {
            for (int j = 0; j < n; j++)
                fill(key[j].begin(), key[j].end(), 0); // 회전 전 0으로 모두 초기화 
            rotate(n, bumpPos); // 회전시키기 (bumPos에 기록, 즉 새로운 돌기 위치 기록)
            for (int j = 0; j < bumpPos.size(); j++) // 회전된 새로운 bumPos에 따라 돌기 위치마다 1 대입
                key[bumpPos[j].first][bumpPos[j].second] = 1;
        } 
        if (answer == false)
            //⭐🌈 DFS 로 이동하러가기 🌈⭐
    }
}
```

DFS 풀이로 위와 같은 코드를 작성하다가 너무 복잡해서 이건 아니다 싶어 포기했다..😅 중도 포기했어서 미완성 코드이긴 하지만 대충 위와 같은 로직으로 작성했었다. 

- `key`를 4가지로 회전 (0도, 90도, 180도, 270도. 회전에 대한 설명은 아래..)
  - 👉 이 각각의 회전마다 "이동 DFS" 진행. **상,하,좌,우 이렇게 4가지의 조합으로 이동을 진행하게 된다.** 
    - 그러다 DFS에서 `lock`의 모든 홈과 `key`의 모든 돌기가 일치할 때, `key`의 돌기가 `lock`의 돌기와 일치하지 않을 때 자물쇠와 열쇠가 맞는 경우를 찾은 것이므로 `answer`를 true로 만들고 DFS 모두 종료.

원래 이와 같은 로직으로 짜는게 내 계획이었다. 근데 `key`를 이동하는 것을 구현하는게 문제였다. 상, 하, 좌, 우마다 한 칸씩 이동할 때 위로 이동할 땐 첫 행 제외 모든 행들을 위로 한칸씩 올려줘야 하고 우로 이동할 땐 첫 행 제외 모든 행들을 오른쪽으로 한 칸씩 밀어줘야 하고.. 또 이중 반복문의 진행은 위에서 아래 행으로, 왼쪽에서 오른쪽 열로 순회하기 때문에 이렇게 한 칸씩 밀 경우 다음에 순회해야 할 곳이 미리 덮어 씌워질 수 있는 아래쪽과 오른쪽은 어떻게 이동 처리를 해야할지 갑갑했다. 😭😭 또한 이렇게 한 칸씩 전부 밀어주어야 하니까 매 DFS 단계마다 O(n^2)이 된다는 얘기와도 같았기 때문에 이렇게 DFS 로 풀면 안되겠다는 생각이 들어 코드를 쓰다가 중단하였다. 

<br>

### ✈ 2 차 풀이 ⭕

```cpp
#include <string>
#include <vector>

using namespace std;

// 현재 모습에서 시계방향 90도로 회전 한 모습으로 pos 에 새로운 1의 위치 기록  
void rotate(int m, vector<pair<int, int>>& pos) {
    for (int i = 0; i < pos.size(); i++) {
        int temp_row = pos[i].first;
        int temp_col = pos[i].second;
        pos[i].first = temp_col;
        pos[i].second = m - 1 - temp_row;
    }
}
```

![image](https://user-images.githubusercontent.com/42318591/108215139-56b85c80-7174-11eb-8b91-113a1e7fb71e.png)


```cpp
bool solution(vector<vector<int>> key, vector<vector<int>> lock) {

    int n = lock.size();
    int m = key.size();

    vector<vector<int>> lockk(2 * m + n - 2, vector<int>(2 * m + n - 2));
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            lockk[m - 1 + i][m - 1 + j] = lock[i][j];

    vector<pair<int, int>> bumpPos;
    for (int i = 0; i < m; i++) 
        for (int j = 0; j < m; j++) 
            if (key[i][j] == 1) 
                bumpPos.push_back(make_pair(i, j));

    for (int i = 0; i < 4; i++) {
        // 회전
        if (i != 0) {
            for (int j = 0; j < m; j++)
                fill(key[j].begin(), key[j].end(), 0);
            rotate(m, bumpPos);
            for (int j = 0; j < bumpPos.size(); j++)
                key[bumpPos[j].first][bumpPos[j].second] = 1;
        }

        // 좌상단 
        for (int j = 0; j < n + m - 1; j++) {
            for (int k = 0; k < n + m - 1; k++) {
                vector<vector<int>> tempLock(lockk);
                for (int x = 0; x < m; x++){
                    for (int y = 0; y < m; y++) {
                        tempLock[j + x][k + y] += key[x][y];
                    }
                }
                bool flag = true;
                for (int i = 0; i < n; i++)
                    for (int j = 0; j < n; j++)
                        if (tempLock[m - 1 + i][m - 1 + j] != 1)
                            flag = false;
                if (flag) 
                    return true;
            }
        }
    }

    return false;
}
```


![image](https://user-images.githubusercontent.com/42318591/108215019-2ffa2600-7174-11eb-9a97-dca10d3ab523.png)

![image](https://user-images.githubusercontent.com/42318591/108215050-36889d80-7174-11eb-9263-a22afa0d87dd.png)

![image](https://user-images.githubusercontent.com/42318591/108215071-3d171500-7174-11eb-92f3-67efba0c81c3.png)


***
<br>

    🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
    언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}