---
title:  "Chapter 1. 재귀(Recursion) : 개념과 기본 예제" 

categories:
  - Algorithm Lesson 1
tags:
  - [Algorithm]

toc: true
toc_sticky: true

date: 2020-07-14
last_modified_at: 2020-07-14
---

권오흠 교수님의 유튜브 강의 **영리한 프로그래밍을 위한 알고리즘 강좌** 를 듣고 정리한 필기입니다. 😀  
{: .notice--warning}

# Chapter1. Recursion

## 🔔 Recursion

> `Recursion` : 자기 자신을 호출 하는 함수 = 재귀 함수

### 무한 루프에 빠지지 않으려면

- `재귀 함수`는 자기 자신을 호출하기 때문에 무한 루프에 빠질 수 있다.
  - 따라서 적어도 하나의 <u>더 이상 자기 자신을 또 호출하지 않는 종료 Case</u>가 존재해야 한다. 

```cpp
int main() 
{
    int result = func(4);
}

int func(int n) 
{
    if (n==0)
        return 0;
    else
        return n + func(n-1);  // 👈
}
```

- 위 코드에서의 종료 조건 👉 n == 0
  - return n + func(n-1);
    - n + 1이였다면 무한 루프.
    - 종료 조건인 n = 0 에 수렴하도록 n 이 작아지는 방향으로 구조를 짜야 한다.
- 호출 과정은 ["C++ 재귀적 함수 호출" 포스트 참고](https://ansohxxn.github.io/cpp/chapter7-10/)

<br>

### 재귀 함수와 수학적 귀납법

> 정리 :  func(int n)은 음이 아닌 정수 n에 대해서 0에서 n
까지의 합을 올바로 계산한다.

- 증명
  1. `n = 0`인 경우 👉 n=0인 경우 0을 반환한다 ⭕
  2. `n < k`인 경우 👉 임의의 양의 정수 k에 대해서 n < k인 경우 0에서 n 까지의 합을 올바르게 계산하여 반환한다고 <u>가정.</u>
  3. `n = k`인 경우 👉 func은 먼저 func(k-1) 호출하는데 2번 가정에 의해서 0에서 k-1까지의 합이 올바로 계산되어 반환된다. 메서드 func은 그 값에 n을 더해서 반환하므로 결국 0에서 k까지의 합을 올바로 계산하여 반환한다. ⭕
    - `func(k) = k + func(k-1)` 에서 2 번 가정에 의해 `func(k-1)`가 올바르므로 `func(k)`도 올바름.

<br>

## 🔔 재귀 함수를 사용하는 알고리즘

### 팩토리얼 n!

> 시간 복잡도 O(n)

```
0! = 1
n! = n X (n-1)!    (n > 0)
```
```cpp
int factorial(int n)
{
    if (n==0)
        return 1;
    else
        return n * factorial(n–1);  // 👈
}
```

<br>

### \\(X^n\\)

> 시간 복잡도 O(n)


- \\(X^0 = 1\\)
- \\(X^n = X * X^{n-1}\\)

```cpp
double power(double x, int n) 
{
    if (n==0)
        return 1;
    else
        return x*power(x, n–1); // 👈
}
```

<br>

### 피보나치 수열

\\[f_0 = 0\\]
\\[f_1 = 1\\]
\\[f_n = f_{n-1} + f{n_2}\\]  

```cpp

int fibonacci(int n) 
{
  if (n<2)
    return n;
  else
    return fibonacci(n-1) + fibonacci(n-2); // 👈
}
```
> 중복 계산이 너무 많아서 <u>재귀로 푸는건 비효율적이다.</u>

```
f(4) = f(3) + f(2) = f(1) + f(2) + f(1) + f(0) = f(1) + f(1) + f(0) + f(1) + f(0)
```
- 중복 多

<br>

### 최대공약수 구하기 Euclid Method

```cpp
int gcd(int m, int n) 
{
  if (m<n) {
    int tmp=m; m=n; n=tmp; // swap m and n
  }
  if (m % n ==0)
    return n;
  else
    return gcd(n, m % n); // 👈 
}
```

- m >= n 인 두 양의 정수 m 과 n 에 대해서 
  - **if (m%n==0)** 
    - m 이 n 의 배수이면 gcd(m, n) = n 이고,
      - 리턴하는 이 n 이 최대 공약수가 된다.
      - 종료 조건
  - **else** 
    - 그렇지 않으면 <u>gcd(m, n)= gcd(n, m%n)</u> 이다.
      - 재귀 
- ex) 15 와 6 의 최대 공약수는
  - gcd(15, 6) 👉 gcd(6, 3) 호출 👉 3 리턴.

#### 더 간단한 버전

```cpp
int gcd(int p, int q) 
{
  if (q==0)
    return p;
  else
    return gcd(q, p % q);
}
``` 
- ex) 15 와 6 의 최대 공약수는
  - gcd(15, 6) 👉 gcd(6, 3) 호출 👉 <u>gcd(3, 0) 호출</u> 👉 3 리턴.
  - 위 예제와 다르게 gcd(3, 0) 까지 간다.

<br>

### 문자열

#### 길이 계산

> 💡 <u>현재 문자열 길이</u> = <u>첫번째 문자를 제외한 문자열의 길이</u> + 1

- 💡 재귀적 아이디어
  - "abcde" 라는 문자열의 길이를 잰다면
    - "abcde".length = "bcde".length + 1
    - "bcde".length = "cde".length + 1
    - "cde".length = "de".length + 1
    - "de".length = "e".length + 1
    - "e".length = "\0".length + 1 
    - "\0".length = 0  👈 <u>종료조건</u>
  - 결론적으로 "abcde".length = 0 + 1 + 1 + 1 + 1 = 5 가 된다.

```cpp
int length(char *str) 
{
    if (*str == ‘\0’)
        return 0;
    else
        return 1 + length(str+1); // 👈
}
```

- char 포인터 `str`가 문자열 배열의 주소를 담게 되면
  - `str+1`은 다음 원소를 가리키므로 다음 원소를 시작점으로 하는 배열을 뜻하게 된다.

```cpp
length(str) = 1 + length(str+1)
```

#### 프린트

```cpp
void printChars(char * str) 
{
    if (*str == ‘\0’)
        return;
    else 
    {
        printf(“%c”, *str);
        printChars(str+1);
    }
}
```

#### 거꾸로 프린트

```cpp
void printCharsReverse(char * str) 
{
    if (*str==‘\0’)
        return;
    else 
    {
        printCharsReverse(str+1);
        printf(“%c”, *str);
    }   
}
```

***
<br>

    🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
    언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}